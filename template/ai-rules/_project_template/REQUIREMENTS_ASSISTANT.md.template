# 要件定義AI補助資料

**⚠️ このファイルはAIエージェント専用です**

このドキュメントは `REQUIREMENTS_PROMPT.md` を実行するAIエージェントが参照すべき
ベストプラクティス、質問テクニック、注意事項をまとめたものです。

---

## 📋 基本方針

### 1. 対話の進め方

**原則**:
- 1ステップずつ進める（一度に複数質問しない）
- ユーザーの回答を待ってから次へ
- 回答が曖昧な場合は具体例を提示して再質問
- 専門用語は避け、わかりやすい言葉で

**NG例**:
```
ステップ1とステップ2を同時に聞く
→ ユーザーが混乱する
```

**OK例**:
```
ステップ1を完了
→ ✅記録しました
→ 次のステップ2へ
```

### 2. 回答の記録

各ステップで以下を内部的に記録：

```python
# 内部データ構造（イメージ）
requirements_data = {
    "step1_background": {
        "problem": "...",
        "current_solution": "...",
        "improvements": "..."
    },
    "step2_users": {
        "main_users": "...",
        "user_count": {...},
        "need_admin": True/False,
        "external_integrations": [...]
    },
    # ... 以降も同様
}
```

最終的にこのデータから REQUIREMENTS.md を生成する。

### 3. 整理・提案

ユーザーの回答が散発的な場合、AIが整理して確認：

**ユーザー回答例**:
```
タスク作成したい、編集も、削除も。
コメントもあったらいいな。
通知も欲しい。
```

**AI整理例**:
```
✅ 以下の機能を挙げていただきました：
- タスクCRUD（作成・編集・削除）
- コメント機能
- 通知機能

これらをPhaseに分けて提案します：

【Phase 1: MVP】
- タスクCRUD

【Phase 2: 拡張】
- コメント機能
- 通知機能

この分け方で問題ありませんか？
```

---

## 🎯 ステップ別ベストプラクティス

### ステップ1: プロジェクト背景・目的

**目的**: プロジェクトの「Why」を明確にする

**質問テクニック**:
- 「なぜこのプロジェクトが必要か」を深掘り
- 現状の痛みを具体化
- 改善後の理想状態を描く

**良い質問例**:
```
Q: 現在、この問題でどんな困りごとがありますか？
   （例: 時間がかかる、ミスが多い、情報が分散）
```

**避けるべき**:
- 抽象的な質問（「課題は何ですか？」だけ）
- 技術的な質問（この段階では早い）

**記録すべき情報**:
- 解決したい課題（具体的に）
- 現状の対応方法
- 改善後の理想状態
- ステークホルダー（誰が困っているか）

---

### ステップ2: ユーザー・ステークホルダー

**目的**: 「誰のため」「誰が使うか」を明確にする

**質問テクニック**:
- ペルソナを具体化
- ユーザー数を見積もる（スケール感）
- 権限設計の必要性を判断

**良い質問例**:
```
Q: メインユーザーはどんな人ですか？
   - 職種は？（例: エンジニア、営業、一般ユーザー）
   - ITリテラシーは？（高/中/低）
   - 人数は？（初期と1年後）
```

**権限設計の判断**:
- 全員平等 → 管理者不要
- 一部に特権 → 管理者必要
- 外部ユーザー → 権限レベル複数

**記録すべき情報**:
- ユーザーペルソナ（役割・人数・ITリテラシー）
- 管理者の有無と権限
- 外部システム連携の必要性

---

### ステップ3: 主要機能の洗い出し

**目的**: 「何を作るか」を網羅的にリストアップ

**質問テクニック**:
- ブレインストーミング形式
- 思いつく限り挙げてもらう
- 優先度は後で整理（この段階では全部出す）

**良い質問例**:
```
Q: どんな機能が必要ですか？思いつく限り挙げてください。

   例:
   - ユーザー登録・ログイン
   - データCRUD
   - 検索・フィルター
   - 通知
   - レポート出力
   - ファイルアップロード
   - その他...

   （遠慮なく、すべて挙げてください）
```

**整理方法**:
ユーザーが挙げた機能を自動で Phase 分解：

1. **Phase 1（MVP）**: 最小限で動くもの
   - 認証
   - 基本CRUD
   - 最低限の画面

2. **Phase 2（拡張）**: 使いやすくするもの
   - 検索・フィルター
   - 通知
   - コメント機能

3. **Phase 3（最適化）**: あると嬉しいもの
   - レポート
   - 分析
   - UI/UX改善

**Phase分解の基準**:
- Phase 1: システムが動作するために必須
- Phase 2: ユーザーが便利に使うために必要
- Phase 3: あると良い、差別化要因

**記録すべき情報**:
- 全機能リスト
- Phase別機能リスト
- 各機能の優先度

---

### ステップ4: データモデル設計

**目的**: 「何を記録するか」を明確にする

**質問テクニック**:
- エンティティ（名詞）を洗い出す
- 主要な属性を列挙
- 関連を確認

**良い質問例**:
```
Q: どんなデータを扱いますか？

   主要なエンティティ（データの塊）を挙げてください。

   例:
   - ユーザー（User）
     → メール、名前、パスワード
   - タスク（Task）
     → タイトル、説明、ステータス、担当者
   - プロジェクト（Project）
     → 名前、説明、メンバー

   エンティティ名と主要な属性を教えてください。
```

**ER図生成**:
ユーザーの回答から自動でER図（テキスト形式）を生成：

```
User（ユーザー）
├─ id: UUID（主キー）
├─ email: string（ユニーク）
├─ password_hash: string
├─ name: string
└─ created_at: timestamp

Task（タスク）
├─ id: UUID（主キー）
├─ title: string
├─ description: text
├─ status: enum (TODO/IN_PROGRESS/DONE)
├─ assignee_id: UUID（FK → User）
├─ created_by: UUID（FK → User）
├─ created_at: timestamp
└─ updated_at: timestamp

関連:
- User ←1:N→ Task（作成者）
- User ←1:N→ Task（担当者）
```

**データ型の推奨**:
- ID: UUID（推奨）または integer（自動採番）
- 日時: timestamp（タイムゾーン付き）
- ステータス: enum（固定選択肢）
- テキスト: string（短文）/ text（長文）
- 真偽値: boolean

**記録すべき情報**:
- エンティティ一覧
- 各エンティティの属性（名前・型・制約）
- エンティティ間の関連（1:1 / 1:N / N:M）

---

### ステップ5: 認証・セキュリティ

**目的**: 「誰が使えるか」「どう守るか」を決める

**質問テクニック**:
- 認証方式の選択肢を提示
- セキュリティ要件をチェックリスト化
- ベストプラクティスを推奨

**認証方式の選択肢**:
```
A. メール＋パスワードのみ（シンプル）
   - 実装が簡単
   - 個人開発・小規模向け

B. メール＋パスワード + OAuth（推奨）
   - ユーザーが登録しやすい
   - セキュリティ向上
   - 中規模以上推奨

C. その他（SSO、SAML等）
   - エンタープライズ向け
```

**セキュリティ要件チェックリスト**:
```
□ HTTPS必須
□ パスワードハッシュ化（bcrypt/Argon2）
□ JWT トークン認証
□ セッション有効期限設定
□ パスワードリセット機能
□ 二段階認証（オプション）
□ CORS設定
□ CSRF対策
□ XSS対策
□ SQL Injection対策（ORM使用）
```

**セッション設定の推奨**:
- アクセストークン: 1時間 ~ 1日
- リフレッシュトークン: 7日 ~ 30日

**記録すべき情報**:
- 認証方式（メール/OAuth/その他）
- OAuth種類（Google/GitHub/etc）
- セキュリティ要件チェックリスト
- セッション設定

---

### ステップ6: API設計

**目的**: 「どう操作するか」を定義する

**質問テクニック**:
- REST / GraphQL の選択（REST推奨）
- データモデルから自動でエンドポイント生成
- RESTful設計原則に従う

**エンドポイント自動生成ロジック**:

データモデル（ステップ4）から：

```python
# 例: Task エンティティ → 以下を自動生成
GET    /api/tasks           # 一覧取得
POST   /api/tasks           # 作成
GET    /api/tasks/:id       # 詳細取得
PUT    /api/tasks/:id       # 更新
DELETE /api/tasks/:id       # 削除
PATCH  /api/tasks/:id/status  # ステータス更新（よくある操作）
```

**RESTful設計原則**:
- リソースは名詞（複数形）
- HTTPメソッドで操作を表現
  - GET: 取得
  - POST: 作成
  - PUT: 全体更新
  - PATCH: 部分更新
  - DELETE: 削除
- ステータスコード適切に使用
  - 200: 成功
  - 201: 作成成功
  - 400: バリデーションエラー
  - 401: 認証エラー
  - 403: 権限エラー
  - 404: Not Found
  - 500: サーバーエラー

**記録すべき情報**:
- API種類（REST/GraphQL）
- 全エンドポイント一覧
- 各エンドポイントの説明
- リクエスト・レスポンス形式（概要）

---

### ステップ7: 画面設計

**目的**: 「どう見せるか」を設計する

**質問テクニック**:
- 主要画面を列挙
- 画面遷移図を自動生成
- 認証前/後で分ける

**画面の分類**:
1. **認証前**
   - ログイン画面
   - ユーザー登録画面
   - パスワードリセット画面

2. **認証後**
   - ダッシュボード（ホーム）
   - 一覧画面
   - 詳細画面
   - 作成・編集画面
   - 設定画面

3. **エラー画面**
   - 404 Not Found
   - 500 Internal Error

**画面遷移図生成例**:
```
[未認証]
ログイン画面 ──登録→ ユーザー登録画面
     │
   ログイン成功
     ↓
[認証済み]
ダッシュボード ←→ 一覧画面
     │              │
     │          詳細クリック
     │              ↓
     └────→ 詳細画面 ←→ 編集画面
                     │
                  設定へ
                     ↓
                 設定画面
```

**記録すべき情報**:
- 全画面リスト
- 画面遷移図
- 各画面の主要機能（簡潔に）

---

### ステップ8: 非機能要件

**目的**: 「どれだけの性能が必要か」を定義する

**質問テクニック**:
- 数値目標を具体的に
- 現実的な目標を提案
- ホスティングプランに応じて調整

**パフォーマンス目標の目安**:

```
【ページ読み込み】
- 高速: 1秒以内
- 標準: 3秒以内（推奨）
- 許容: 5秒以内

【API応答時間】
- 高速: 100ms以内
- 標準: 500ms以内（推奨）
- 許容: 1秒以内

【リアルタイム更新】
- 高速: 100ms以内
- 標準: 500ms以内（推奨）
- 許容: 1秒以内
```

**可用性目標の目安**:
```
- 99.9%（スリーナイン）: 月間ダウンタイム 43分
- 99%: 月間ダウンタイム 7時間
- 95%: 月間ダウンタイム 36時間
- ベストエフォート: 目標なし

推奨: 個人開発 95%、ビジネス 99%
```

**スケーラビリティの考慮**:
```
初期ユーザー数 × 10 = 1年後想定

例:
- 初期 10名 → 1年後 100名
- 初期 100名 → 1年後 1,000名
```

**記録すべき情報**:
- パフォーマンス目標（ページ/API/リアルタイム）
- 可用性目標（稼働率%）
- 想定ユーザー数（初期/1年後）
- バックアップ戦略（頻度・方法）

---

### ステップ9: 予算・スケジュール

**目的**: 「いつまでに」「いくらで」を決める

**質問テクニック**:
- 現実的なスケジュールを提案
- Phase別に期間を算出
- リスクバッファを含める

**スケジュール算出ロジック**:

```python
# Phase 1（MVP）の工数見積もり
features = len(phase1_features)  # Phase 1の機能数
complexity = 1.0  # 複雑度（1.0=標準、1.5=複雑、0.5=簡単）

# 1機能あたり 2-3日
days_per_feature = 2.5
phase1_days = features * days_per_feature * complexity

# テスト・デプロイ期間（20%）
phase1_days *= 1.2

# Phase 2（拡張）は Phase 1の 1.5倍
phase2_days = phase1_days * 1.5

# Phase 3（最適化）は Phase 2と同等
phase3_days = phase2_days
```

**予算の目安**:

```
【無料範囲】
- Vercel（Frontend）: 無料
- Netlify: 無料
- Supabase: 無料（制限あり）

【有料範囲】
- AWS EC2 t3.micro: $10/月
- PostgreSQL（Supabase有料）: $25/月
- Sentry（エラー監視）: $26/月

推奨:
- 個人開発: 無料 ~ $10/月
- ビジネス: $50 ~ $100/月
```

**記録すべき情報**:
- 予算（月額・初期費用）
- Phase別スケジュール
- チーム構成（人数・役割）
- マイルストーン（Phase完了日）

---

### ステップ10: リスク管理

**目的**: 「何が問題になりそうか」を予測・対策

**質問テクニック**:
- ユーザーの懸念を聞く
- よくあるリスクを提案
- 各リスクに対策を提示

**よくあるリスク**:

```
【技術的リスク】
- 未経験の技術スタック
  → 対策: 小規模プロトタイプで検証

- リアルタイム更新の実装難度
  → 対策: ライブラリ使用（Socket.io等）

- パフォーマンス問題
  → 対策: 初期は最適化後回し

【リソースリスク】
- 単独開発のボトルネック
  → 対策: AI エージェント活用

- 時間不足
  → 対策: Phase分割、優先度明確化

【運用リスク】
- ホスティング無料プラン制限超過
  → 対策: 使用量監視、有料プラン準備

- データ消失
  → 対策: 自動バックアップ設定
```

**リスク評価マトリクス**:
```
影響度 × 発生確率 = 優先度

高 × 高 = 最優先対策
高 × 低 = 監視・準備
低 × 高 = 軽減措置
低 × 低 = 受容
```

**記録すべき情報**:
- リスク一覧（技術的/リソース/運用）
- 各リスクの影響度・発生確率
- 対策（予防/軽減/転嫁/受容）

---

## ✅ 最終チェックリスト

ドキュメント生成前に以下を確認：

### 必須項目
- [ ] プロジェクト背景・目的が明確
- [ ] ユーザー・ステークホルダー定義
- [ ] 主要機能リスト（Phase分解済み）
- [ ] データモデル（エンティティ・関連）
- [ ] 認証・セキュリティ要件
- [ ] API設計（エンドポイント一覧）
- [ ] 画面設計（画面遷移図）
- [ ] 非機能要件（性能・可用性）
- [ ] 予算・スケジュール
- [ ] リスク管理

### 品質確認
- [ ] 具体的な数値目標がある
- [ ] Phase分解が適切
- [ ] 優先度が明確
- [ ] 実現可能性が検証されている
- [ ] ユーザー視点で書かれている

### ドキュメント生成準備
- [ ] 全10ステップ完了
- [ ] 内部データ構造に記録済み
- [ ] ユーザー確認済み

---

## 📝 生成するドキュメント

### 1. `ai-rules/{{PROJECT_NAME}}/REQUIREMENTS.md`

**目的**: AI向け詳細要件定義書

**構成**:
- プロジェクト背景・目的（詳細）
- ユーザー・ステークホルダー
- 主要機能（Phase別、詳細）
- データモデル（ER図、属性、関連）
- 認証・セキュリティ（詳細設定）
- API設計（全エンドポイント、リクエスト/レスポンス）
- 画面設計（画面遷移図、各画面の説明）
- 非機能要件（具体的な数値目標）
- 予算・スケジュール（Phase別詳細）
- リスク管理（リスクと対策）

**文字数**: 3000-5000行

### 2. `docs/REQUIREMENTS.md`

**目的**: 人間向け要件概要

**構成**:
- プロジェクト概要（1-2段落）
- 主要機能（箇条書き、Phase別）
- 技術スタック（表形式）
- データモデル（概要のみ）
- スケジュール（表形式）

**文字数**: 50-100行

### 3. `.serena/memories/project_overview.md`

**目的**: AI が常に参照するプロジェクト概要

**構成**:
- 基本情報
- 目的
- 主要機能
- データモデル
- 現在のステータス

**文字数**: 100-200行

---

## 🔧 トラブルシューティング

### Q1: ユーザーの回答が曖昧

**対策**: 具体例を提示して再質問

```
ユーザー: 「タスク管理をしたい」

AI: 「タスク管理について、もう少し具体的に教えてください。
例えば：
- タスクの作成・編集・削除
- タスクのステータス管理（TODO/進行中/完了）
- タスクへのコメント
- タスクへのファイル添付
- タスクの担当者設定

どの機能が必要ですか？」
```

### Q2: ユーザーが技術的に詳しくない

**対策**: 平易な言葉で説明、選択肢を提示

```
❌ 「OAuth 2.0を使いますか？」

✅ 「ログイン方法について、以下のどれが良いですか？

A. メールアドレスとパスワードでログイン（シンプル）
B. Googleアカウントでログイン（ユーザーが便利）
C. 両方使える（推奨）

選択: [A/B/C]」
```

### Q3: 機能が多すぎて整理できない

**対策**: Phase分解して優先度を明確化

```
ユーザーが20個の機能を挙げた場合：

AI: 「たくさんの機能を挙げていただきました。
Phase分けして優先度を決めましょう。

【Phase 1: 最低限これがないと動かない】
- [3-5個の機能]

【Phase 2: あると便利】
- [5-8個の機能]

【Phase 3: あると嬉しい】
- [残りの機能]

この分け方で問題ありませんか？」
```

### Q4: スケジュールが現実的でない

**対策**: 工数を再計算して提案

```
ユーザー: 「Phase 1を1週間で」

AI: 「Phase 1の機能を見積もると、以下の工数が必要です：
- 認証実装: 3日
- タスクCRUD: 5日
- カンバンボード: 4日
- テスト: 2日
合計: 14日（約2週間）

1週間で完了するには、機能を減らす必要があります。
例えば、Phase 1をさらに絞って：
- 認証 + 簡易タスクリスト（カンバンなし）

この調整で問題ありませんか？」
```

---

**バージョン**: 1.0
**作成日**: {{CURRENT_DATE}}
